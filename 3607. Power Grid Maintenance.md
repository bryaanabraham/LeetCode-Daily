You are given an integer c representing c power stations, each with a unique identifier id from 1 to c (1‑based indexing).
These stations are interconnected via n bidirectional cables, represented by a 2D array connections, where each element connections[i] = [ui, vi] indicates a connection between station ui and station vi. Stations that are directly or indirectly connected form a power grid.
Initially, all stations are online (operational).
You are also given a 2D array queries, where each query is one of the following two types:
[1, x]: A maintenance check is requested for station x. If station x is online, it resolves the check by itself. If station x is offline, the check is resolved by the operational station with the smallest id in the same power grid as x. If no operational station exists in that grid, return -1.
[2, x]: Station x goes offline (i.e., it becomes non-operational).
Return an array of integers representing the results of each query of type [1, x] in the order they appear.
Note: The power grid preserves its structure; an offline (non‑operational) node remains part of its grid and taking it offline does not alter connectivity.

```python
### BFS Approach: TLE error:
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        graph = {}
        status = {}
        for i in range(1,c+1):
            graph[i] = set()
            status[i] = 1
        for i, j in connections:
            graph[i].add(j)
            graph[j].add(i)
        
        print(graph)
        print(status)

        def bfs(start):
            ans = []
            visited = {start}
            q = deque([start])
            while q:
                node = q.popleft()
                for nei in graph[node]:
                    if nei in visited:
                        continue
                    if status[nei] == 1:
                        ans.append(nei)
                    visited.add(nei)
                    q.append(nei)

            return ans if ans != [] else [-1]

        ans = []
        for query in queries:
            if query[0] == 2:
                status[query[1]] = 0
            elif query[0] == 1:
                if status[query[1]] == 1:
                    ans.append(query[1])
                else:
                    ans.append(min(bfs(query[1])))
            
        return ans
```
Solution:
- To avoid the need to do a complete BFS traversal on every turn to get the minimum value of the station ID we use a sorted data structure (MinHeap)
- Use a min heap to get the minimum online station but instead of deleting (which is computationally expensive) we maintain a hash set (do a lazy delete)
```python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        for i, j in connections:
            graph[i].append(j)
            graph[j].append(i)
        
        online = set(range(1, c + 1))
        station_group = {}
        min_heaps = defaultdict(list)

        def dfs(station, group_id):
            if station in station_group:
                return
            station_group[station] = group_id
            heappush(min_heaps[group_id], station)
            for nei in graph[station]:
                dfs(nei, group_id)
        
        for s in range(1, c + 1):
            if s not in station_group:
                dfs(s, s)
        
        ans = []
        for q, s in queries:
            if q == 1:
                if s in online:
                    ans.append(s)
                    continue
                group_id = station_group[s]
                min_heap = min_heaps[group_id]
                
                while min_heap and min_heap[0] not in online:
                    heappop(min_heap)
                ans.append(min_heap[0] if min_heap else -1)
            else:
                online.discard(s)

        return ans
```
