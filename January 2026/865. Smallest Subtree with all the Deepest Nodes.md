Given the root of a binary tree, the depth of each node is the shortest distance to the root.

Return the smallest subtree such that it contains all the deepest nodes in the original tree.

A node is called the deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.

Solution:
- The first phase is to identify the nodes of the tree that are deepest. To do this, we have to annotate the depth of each node. We can do this with a depth first search.
- We will use that annotation to help us find the answer:
  - If the node in question has maximum depth, it is the answer.
  - If both the left and right child of a node have a deepest descendant, then the answer is this parent node.
  - Otherwise, if some child has a deepest descendant, then the answer is that child.
  - Otherwise, the answer for this subtree doesn't exist.
 
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        depth = {None: -1}

        def dfs(node, parent=None):
            if node:
                depth[node] = depth[parent] +1
                dfs(node.left, node)
                dfs(node.right, node)
        dfs(root)

        max_depth = max(depth.values())

        def solve(node):
            if not node or depth.get(node, None) == max_depth:
                return node
            l, r = solve(node.left), solve(node.right)
            return node if l and r else l or r

        return solve(root)

```
