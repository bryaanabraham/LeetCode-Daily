You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.
Each power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.
Note that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.
The power of a city is the total number of power stations it is being provided power from.
The government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.
Given the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.
Note that you can build the k power stations in multiple cities.

Brute force solution:
- create a difference-array to keep track of power at each station.
- can_achieve funtion checks if it is possible to achieve at least target_p power at every station
- iterate from high to low to get the maximin power that can be achieved at every station.

```python
### Brute Force: TLE
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        N = len(stations)
        diff = [0]*(N+1)

        for i in range(N):
            left = max(i-r,0)
            right = min(i+r+1, N)
            diff[left] += station[i]
            diff[right] -= station[i]

        def can_achieve(target_p):
            pass

        low, high = min(station), sum(stations)+k
        for target_p in reversed(range(low,high+1)):
            if can_achieve(target_p):
                return target_p
        
        return low
```

Solution: replace the for loop with a Binary Search approach to reach the optimal target_p in log(N+r) time for that code block.

```python
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        N = len(stations)
        diff = [0]*(N+1)

        for i in range(N):
            left = max(i-r,0)
            right = min(i+r+1, N)
            diff[left] += stations[i]
            diff[right] -= stations[i]

        def can_achieve(target_p):
            curr_p = 0
            curr_k = k
            diff_copy = diff.copy()
            for i in range(N):
                curr_p += diff_copy[i]
                if curr_p < target_p:
                    balance = target_p - curr_p
                    if balance > curr_k:
                        return False
                    curr_k -= balance
                    curr_p += balance
                    left = i
                    right = min(i+2*r+1, N)
                    diff_copy[left] +=balance
                    diff_copy[right] -=balance
            return True

        low, high = min(stations), sum(stations)+k
        ans = low
        while low<=high:
            target_p = (low+high)//2
            if can_achieve(target_p):
                ans = target_p
                low = target_p+1
            else:
                high = target_p-1
        
        return ans
```
